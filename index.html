<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MMI-kake</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      padding: 8px 12px;
      border-bottom: 1px solid #ddd;
      font-size: 14px;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    header button {
      padding: 4px 8px;
      font-size: 13px;
      cursor: pointer;
    }
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 12px;
      gap: 8px;
    }
    #status {
      font-size: 13px;
      opacity: 0.9;
    }
    #error {
      color: #b00020;
      font-size: 13px;
    }
    #chartContainer {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
    }
  </style>
</head>

<body>
  <header>
    <div>MMI-kake</div>
    <button id="reloadButton">Hent fra modell</button>
    <button id="colorizeButton">Fargelegg objekter</button>
  </header>

  <main>
    <div id="status">Connecting to Trimble Connect…</div>
    <div id="chartContainer">
      <canvas id="mmiChart"></canvas>
    </div>
    <div id="error"></div>
  </main>

  <script>
    let API = null;
    let chart = null;

    // Store last loaded result so color button can reuse it
    let lastSelectionByMmi = null;

    const VALID_MMI_VALUES = [100, 200, 300, 350, 400];

    const MMI_COLORS = {
      "100": "rgb(190, 40, 35)",
      "200": "rgb(230, 150, 55)",
      "300": "rgb(250, 240, 80)",
      "350": "rgb(185, 175, 60)",
      "400": "rgb(55, 130, 70)"
    };

    function normalizeName(name) {
      return (name || "").toString().toUpperCase().replace(/[\s\-]+/g, "_");
    }

    function parseRgbToRgba(rgbString) {
      const m = rgbString.match(/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/);
      if (!m) return null;
      return { r: +m[1], g: +m[2], b: +m[3], a: 255 };
    }

    async function connectToWorkspace() {
      API = await TrimbleConnectWorkspace.connect(window.parent, () => {}, 30000);
      document.getElementById("status").textContent = "Connected.";
    }

    async function getMmiData() {
      const modelObjectsList = await API.viewer.getObjects();

      const counts = {100:0,200:0,300:0,350:0,400:0};
      const selectionByMmi = {100:{},200:{},300:{},350:{},400:{}};

      for (const modelObjects of modelObjectsList) {
        const modelId = modelObjects.modelId;
        const objs = modelObjects.objects || [];
        const ids = objs.map(o => o.id);
        if (!ids.length) continue;

        const propsArray = await API.viewer.getObjectProperties(modelId, ids);

        for (const obj of propsArray) {
          for (const pset of obj.properties || []) {
            for (const p of pset.properties || []) {
              if (normalizeName(p.name) !== "01_MMI") continue;

              const v = parseInt(p.value);
              if (!VALID_MMI_VALUES.includes(v)) continue;

              counts[v]++;
              if (!selectionByMmi[v][modelId]) selectionByMmi[v][modelId] = [];
              selectionByMmi[v][modelId].push(obj.id);
              break;
            }
          }
        }
      }

      return { counts, selectionByMmi };
    }

    async function applyMmiColors(selectionByMmi) {
      await API.viewer.setObjectState(undefined, { color: "reset" });

      for (const mmi of VALID_MMI_VALUES) {
        const perModel = selectionByMmi[mmi];
        if (!perModel) continue;

        const color = parseRgbToRgba(MMI_COLORS[String(mmi)]);
        const modelObjectIds = [];

        for (const modelId of Object.keys(perModel)) {
          modelObjectIds.push({
            modelId,
            objectRuntimeIds: perModel[modelId]
          });
        }

        if (modelObjectIds.length) {
          await API.viewer.setObjectState({ modelObjectIds }, { color });
        }
      }
    }

    function renderPieChart(counts) {
      const ctx = document.getElementById("mmiChart").getContext("2d");

      const labels = [];
      const vals = [];
      const cols = [];

      for (const mmi of VALID_MMI_VALUES) {
        if (counts[mmi] > 0) {
          labels.push(String(mmi));
          vals.push(counts[mmi]);
          cols.push(MMI_COLORS[String(mmi)]);
        }
      }

      if (chart) chart.destroy();

      chart = new Chart(ctx, {
        type: "pie",
        data: { labels, datasets: [{ data: vals, backgroundColor: cols }] }
      });
    }

    async function loadChart() {
      const status = document.getElementById("status");
      const { counts, selectionByMmi } = await getMmiData();

      lastSelectionByMmi = selectionByMmi;

      renderPieChart(counts);
      await applyMmiColors(selectionByMmi);

      status.textContent = "MMI data og fargelegging oppdatert.";
    }

    document.getElementById("reloadButton").onclick = loadChart;

    // NEW BUTTON – only colors objects
    document.getElementById("colorizeButton").onclick = async () => {
      if (!lastSelectionByMmi) {
        document.getElementById("error").textContent =
          "Ingen data lastet enda. Trykk først på 'Hent fra modell'.";
        return;
      }
      await applyMmiColors(lastSelectionByMmi);
      document.getElementById("status").textContent =
        "Farger oppdatert basert på lagrede MMI-verdier.";
    };

    (async () => {
      await connectToWorkspace();
    })();
  </script>
</body>
</html>
